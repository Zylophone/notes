* Array and String
** Exercises [8/9]
  - [X] *Is Unique*: Implement an algorithm to determine if a string has
    all unique  characters.  What  if you  cannot use  additional data
    structures?
    1. This  solution is ~O(len(string) +  len(letters.values))~, thus
       ~O(n)~.   I  am  making  the assumption  that  hash  access  is
       constant.
      #+BEGIN_SRC ruby
  def is_unique?(string)
    letters = Hash.new(0)
    string.each_char do |char|
      letters[char] += 1
    end
    letters.values.select{|counter| counter > 1}.empty?
  end
     #+END_SRC
    2. This solution is ~O(n * log(n) + n)~, thus ~O(n * log n)~.  I am
       assuming that I cannot use an additional data structure.
       #+BEGIN_SRC ruby
  def is_unique?(string)
    sorted_string = string.split(//).sort
    next_index = 1
    result = true
    sorted_string[0..-2].each do |char|
      if char == sorted_string[next_index]
	result = false
	break
      end
      next_index += 1
    end
    result
  end
       #+END_SRC

  - [X] *Check permutation* Given two strings write a method to decide
    if one is a permutation of the other.
    #+BEGIN_SRC ruby
    def permutation(s1, s2)
      new_s1 = s1.split(//)
      new_s2 = s2.split(//)
      store = {}
      new_s2.each do |char|
        store[char] = true
      end

      result = true
      new_s1.each do |char|
        if !store.has_key?(char)
          result = false
	  break
	end
      end
      result
    end
    #+END_SRC

  - [X] *URLify*
    The solution is ~O(n + n)~, this ~O(n)~.

    #+BEGIN_SRC ruby
def urilify(string_array, size)
  spaces_index = []
  string_array[0..(size - 1)].each_with_index do |char, index|
    spaces_index << index if char == " "
  end

  current_index = spaces_index.count * 2 + size - 1
  string_index = size - 1

  while(current_index >= 0) do
    if spaces_index.include?(string_index)
      string_array[current_index] = "0"
      string_array[current_index - 1] = "2"
      string_array[current_index - 2] = "%"
      current_index -= 3
    else
      string_array[current_index] = string_array[string_index]
      current_index -= 1
    end
    string_index -= 1
  end
  string_array
end
    #+END_SRC

  - [X] *Palindrome  Permutation*  Given  a  string,  check  if  any
    permutation of  it is a palindrome.   The solution I came  up is a
    recursive  solution,  and I'm  pretty  sure  that is  exponential.
    However I don't know how to prove that.
    #+BEGIN_SRC ruby
def remaining_array(init, array)
  size = array.count
  size.times.map do |index|
    i = (init + index) % size
    array[i]
  end[1..-1]
end


def permutation(array)
  return array if array.empty?
  return [array] if array.count == 1
  results = []
  array.each_with_index do |e, index|
    permutation(remaining_array(index, array)).each do |a|
      results << [e].concat(a)
    end
  end
  results
end

def palindrome?(array)
  left_index = 0
  right_index = -1
  flag = true
  limit = (array.size/2.to_f).ceil
  array.size.times do |index|
    if right_index.abs > limit
      break
    end

    if array[index] != array[right_index] && (!array[index].blank? && !array[right_index].blank?)
      flag = false
      break
    end
    right_index -= 1
  end
  flag
end

def is_palindrome(s1)
  array = s1.split(//)
  permutation(array).select{|a| palindrome?(a) == true}.any?
end
    #+END_SRC

  - [X] *One Away*
    Given two strings, write a function to check if they are one edit (or zero edits) away.
    #+BEGIN_SRC ruby
def is_one_away?(s1, s2)
  longest, shortest = s1.size > s2.size ? [s1, s2] : [s2, s1]
  counter = 0
  shortest_index = 0
  longest.split(//).each_with_index do |char, index|
    if char == shortest[shortest_index]
      shortest_index += 1
      next
    end

    if longest[index+1] == shortest[shortest_index]
      counter += 1
    elsif longest[index+1] == shortest[shortest_index+1]
      counter += 1
      shortest_index += 1
    end
  end
  counter <= 1 ? true : false
end

is_one_away?("pale", "ple") == true
is_one_away?("pales", "pale") == true
is_one_away?("pale", "bale") == true
is_one_away?("pale", "bake") == false
    #+END_SRC

  - [X] *String Compression*
    aabcccccaaa `->` a2b1c5a3
    #+BEGIN_SRC ruby
def compress(string)
  normalized_string = string.split(//)
  repetitions = 0
  previous = normalized_string[0]
  new_string = ""
  normalized_string.each do |char|
    if (char == previous)
      repetitions += 1
    else
      new_string += "#{previous}#{repetitions}"
      previous = char
      repetitions = 1
    end
  end
  if normalized_string[-1] == previous
    new_string += "#{previous}#{repetitions}"
  end
  new_string
end
    #+END_SRC

  - [ ] *Rotate Matrix*

  - [X] *Zero Matrix* Given a MxN matrix, write an algorithm such that
    if an element is 0, its entire row and columns are set to 0.
    #+BEGIN_SRC ruby
def zero_matrix(matrix, row_count, column_count)
  rows = []
  columns = []
  matrix.each_with_index do |row, row_index|
    row.each_with_index do |element, column_index|
      if element == 0
        rows << row_index
        columns << column_index
      end
    end
  end
  rows.uniq.each do |row_index|
    matrix[row_index] = column_count.times.map{|c| 0}
  end
  columns.uniq.each do |column_index|
    matrix.each do |row|
      row[column_index] = 0
    end
  end
  matrix
end

zero_matrix([[1, 2], [3, 4], [5, 0]], 3, 2) == [[1, 0], [3, 0], [0, 0]]
    #+END_SRC

  - [X] *String Rotation*
    "waterbottle" is a rotation of "erbottlewat"
    #+BEGIN_SRC ruby
    def is_rotation(s1, s2)
      "#{s2}#{s2}".include?(s1)
    end

    is_rotation("waterbottle", "erbottlewat") == true
    #+END_SRC
** Implementations
*** Hash Table
    - Compute key's hash code
    - Map the key's hash code to an index in the array
    - In that position we need to store the key and value
      - use a linked list
    - Is it possible to use a binary search tree?

      This implementation uses a linked list and a fixed size array
      #+BEGIN_SRC ruby
class Node
  attr_accessor :key, :value, :next_node
  def initialize(key, value, next_node = nil)
    self.key = key
    self.value = value
    self.next_node = next_node
  end
end

class EmptyNode
  attr_accessor :key, :value, :next_node
end

class LinkedList
  attr_accessor :first_node, :size

  def initialize(node = nil)
    node = node ? node : EmptyNode.new()
    self.first_node = node
    self.size = 1
  end

  def add(key, value)
    node = Node.new(key, value, self.first_node)
    self.first_node = node
    self.size += 1
    self
  end

  def find
    return if !block_given?

    current = self.first_node
    found = false
    self.size.times.each do
      found = yield current
      break if found
      current = current.next_node
    end
    current if found
  end
end

class MyHash
  attr_accessor :array, :size
  def initialize(size = nil)
    self.size = 50
    self.array = self.size.times.map do
      LinkedList.new()
    end
  end

  def add(key, value)
    hash_value = hash_for(key)
    array_index = hash_value % self.size
    self.array[array_index].add(key, value)
    self
  end

  def value(key)
    hash_value = hash_for(key)
    array_index = hash_value % self.size
    node = self.array[array_index].find do |node|
      node.key == key
    end
    node.value if node
  end

  private
  def hash_for(key)
    md5 = Digest::MD5.new
    md5.update(key.to_s).hexdigest.to_i
  end
end
      #+END_SRC

      This implementation is using BST
      #+BEGIN_SRC ruby
class TreeNode
  attr_accessor :key, :value, :left_node, :right_node
  def initialize(key, value, left_node = EmptyTreeNode.new, right_node = EmptyTreeNode.new)
    self.key = key
    self.value = value
    self.left_node = left_node
    self.right_node = right_node
  end

  def add(key, value)
    left_node = self.left_node
    right_node = self.right_node
    if key > self.key
      right_node = self.right_node.add(key, value)
    else
      left_node = self.left_node.add(key, value)
    end
    TreeNode.new(self.key, self.value, left_node, right_node)
  end

  def find_by(key)
    return self if key == self.key

    if key > self.key
      self.right_node.find_by(key)
    else
      self.left_node.find_by(key)
    end
  end
end

class EmptyTreeNode
  def add(key, value)
    TreeNode.new(key, value)
  end

  def find_by(key)
    self
  end

  def value
    nil
  end
end

class MyHashUsingBST
  attr_accessor :tree
  def initialize()
    self.tree = EmptyTreeNode.new
  end

  def add(key, value)
    self.tree = self.tree.add(key, value)
  end

  def value(key)
    self.tree.find_by(key).value
  end
end

m = MyHashUsingBST.new
m.add(:milton, 5)
m.add(:ivania, 10)
m.value(:milton)
m.value(:ivania)
    #+END_SRC

*** ArrayList & Resizable Arrays
    - Create an array with a fixed amount of elements
    - Insert data
    - When full expand it to the double

*** String Builder
    - sentence =  sentence + w -->  will create a new  string instance
      each time
    - StringBuilder uses an arraylist and concatenate all the elements
      at the end building a string

* Breadth Tree Traversal
  #+BEGIN_SRC ruby
  class Node < Struct.new(:data, :left, :right)
    def breadth(acc = "")
      queue = Queue.new
      queue << self
      while !queue.empty? do
        current = queue.pop
	acc += "#{current.data}-"
	queue << current.left if current.left
	queue << current.right if current.right
      end
      puts acc
    end
  end

  #         :a
  #    :b        :c
  # :d    :e  :f
  r = Node.new(:a, Node.new(:b, Node.new(:d), Node.new(:e)), Node.new(:c, Node.new(:f)))
  > r.breadth
  a-b-c-d-e-f-
  #+END_SRC
