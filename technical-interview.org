* Data Structures
** Linear
*** Array
Stores homogeneous elements at contiguous locations. Size of an array must be provided before storing data.
**** Unsorted Array
***** Search
#+BEGIN_SRC ruby
def search(arr, element)
  exists = false
  arr.each do |ele|
    if ele == element
      exists = true
      break
    end
  end
  exists
end
#+END_SRC
***** Insert
#+BEGIN_SRC ruby
def insert(arr, index, element, capacity)
  if index == capacity
    index
  else
    arr[index] = element
    index + 1
  end
end

def main(array_size)
  arr = Array.new(array_size)
  current_index = 0
  (1.. (array_size + 100)).each do |element|
    current_index = insert(arr, current_index, element, array_size)
  end
  arr
end
#+END_SRC
***** Delete
#+BEGIN_SRC ruby
def search(arr, size, key)
  position = -1
  (0..(size - 1)).each do |index|
    if arr[index] == key
      position = index
    end
  end
  position
end

def my_print(arr, current_index)
  (0..current_index.each do |index|
    puts arr[index]
  end
end

def delete(arr, size, element)
  index = search(arr, size, element)
  return size if index == -1

  #this is equivalent to for(i=index, i < n -1, i++)
  (index..(size - 2)).each do |current_index|
    arr[current_index] = arr[current_index + 1]
  end
  size - 1
end
#+END_SRC

**** Sorted Array
***** Search
If array is sorted, binary search can be used to find the key
#+BEGIN_SRC ruby
def binary_search(arr, low, high, key)
  return -1 if low > high
  mid = low + (high - low)/2
  if arr[mid] == key
    return mid
  end
  if key < arr[mid]
    binary_search(arr, low, mid - 1, key)
  else
    binary_search(arr, mid + 1, high, key)
  end
end
#+END_SRC
***** Insert
Can I do it better? I started from start to end. What would happen if I start from end to start?
#+BEGIN_SRC ruby
def insert(arr, current_index, capacity, key)
  return current_index if current_index == capacity
  position = -1
  (0..current_index).each do |index|
    if arr[index] > key
      position = index
      break
    end
  end
  return current_index if position == -1
  (position..current_index + 1).each do |index|
    old = arr[index]
    arr[index] = key
    key = old
  end
  current_index + 1
end
#+END_SRC
***** Delete
#+BEGIN_SRC ruby
def delete(arr, current_index, capacity, key)
  position = binary_search(arr, 0, current_index,  key)
  return current_index if position == -1
  (position..current_index-1).each do |index|
    arr[index] = arr[index+1]
  end
  current_index - 1
end

#+END_SRC
*** LinkedList
Elements are not stored at contiguous location; the elements are linked using pointers
**** Advantages over Array
  - Dynamic Size; no need to know the size in advance
  - Ease of insertion/deletion
**** Disavantages
  - Random Access is not allowed; binary search is not possible
  - Extra memory space for storing the pointer
**** Structure
#+BEGIN_SRC ruby
class Node
  attr_accessor :data, :next
  def initialize(data, next_node = nil)
    self.data = data
    self.next = next_node
  end
end

class LinkedList
  attr_accessor :head
  def initialize(head = nil)
    self.head = head
  end
end
#+END_SRC
**** Traversal
#+BEGIN_SRC ruby
def my_print(linked_list)
  current = linked_list.head
  while current != nil
    puts current.data
    current = current.next
  end
end
#+END_SRC
**** Insertion
#+BEGIN_SRC ruby
class LinkedList
  def push(element)
    node = Node.new(element, self.head)
    self.head = node
  end

  def insert_after(current_node, element)
    node = Node.new(element, current_node.next)
    current_node.next = node
  end

  def append(element)
    node = Node.new(element)
    prev = nil
    current = self.head
    while current != nil
      prev = current
      current = current.next
    end
    if self.head.nil?
      self.head = node
    else
      prev.next = node
    end
  end
end
#+END_SRC
**** Deletion
#+BEGIN_SRC ruby
class LinkedList
  def deleteNode(key)
    current = self.head
    while current.next != nil
      if current.next.data == key
        current.next = current.next.next
        break
      end
      current = current.next
    end
  end

  def deleteNodeByPosition(position)
    return if self.head == nil

    if position == 0
      self.head = self.head.next
      return
    end

    index = 0
    current = self.head
    while current.next != nil
      if index + 1 == position
        current.next = current.next.next
        break
      end
      current = current.next
      index = index + 1
    end
  end
end
#+END_SRC
**** Exercises
***** Length
#+BEGIN_SRC ruby
class LinkedList
  def length
    current = self.head
    counter = 0
    while current != nil
      counter = counter + 1
      current = current.next
    end
    counter
  end
end
#+END_SRC
***** Search an Element
#+BEGIN_SRC ruby
class LinkedList
  def search_iterative(key)
    current = self.head
    found = false
    while current != nil
      if key == current.data
        found = true
        break
      end
      current = current.next
    end
    found
  end

  def search_recursive(key, current=self.head)
    if current == nil
      false
    else
       if key == current.data
         true
       else
         search_recursive(key, current.next)
       end
    end
  end
end
#+END_SRC
***** DeleteFirst
#+BEGIN_SRC ruby
class LinkedList
  def delete_first
    return if self.head.nil?

    head = self.head
    new_head = head.next
    self.head = new_head
    head = nil
  end
end
#+END_SRC

***** Swap Nodes
#+BEGIN_SRC ruby
class LinkedList
  def swap(x, y)
    #Cases:
    #1. x or y can be head
    #2. x and y can be adjacents nodes
    #3. x and y are not adjacents nodes
    current = self.head
    prevX = currentX = prevY = currentY = nil
    while current != nil
      if current.data == x
        currentX = current
      elsif current.data == y
        currentY = current
      end
      if currentX.nil?
        prevX = current
      end
      if currentY.nil?
        prevY = current
      end
      break if [currentX, currentY].compact.size == 2
      current = current.next
    end
    return if [currentX, currentY].compact.size != 2

    newNextY = currentX.next
    newNextX = currentY.next
    if currentY == newNextY
      currentY.next = currentX
    else
      currentY.next = newNextY
    end
    currentX.next = newNextX
    if prevX.nil?
      self.head = currentY
    else
      prevX.next = currentY
    end
    if prevY != currentX
      prevY.next = currentX
    end
  end
end
#+END_SRC
***** Get nth element
#+BEGIN_SRC ruby
class LinkedList
  def nth(key_index)
    index = 1
    current = self.head
    while current != nil
      if index == key_index
        break
      else
        index = index + 1
        current = current.next
      end
    end
    current.data if current
  end
end
#+END_SRC
***** (16) Reverse
#+BEGIN_SRC ruby
class LinkedList
  def reverse
    current = self.head
    next_node = nil
    while current != nil
      prev = current.next
      current.next = next_node
      next_node = current
      current = prev
      prev = prev.next if prev
    end
    self.head = next_node
  end
end
#+END_SRC
***** (17) Detect Loop
****** Modifiying Node
#+BEGIN_SRC ruby
class Node
  attr_accessor :visited
end

class LinkedList
  def loop?
    loop = false
    current = self.head
    while current != nil
      if !current.visited
        current.visited = true
      else
        loop = true
        break
      end
      current = current.next
    end
    loop
  end
end
#+END_SRC
****** Using Hash
#+BEGIN_SRC ruby
class LinkedList
  def loop_hash?
    loop = false
    node_hash = {}
    current = self.head
    while current != nil
      if node_hash.has_key?(current)
        loop = true
        break
      else
        node_hash[current] = true
      end
      current = current.next
    end
    loop
  end
end
#+END_SRC
****** Using Floyd's Cycle-Finding Algorithm
#+BEGIN_SRC ruby
class LinkedList
  def loop_floyd?
    loop = false
    current = self.head
    slow = current
    fast = current
    while current != nil and slow != nil and fast != nil
      slow = current.next
      fast = current.next.next
      if slow == fast
        loop = true
        break
      end
      current = current.next
    end
    loop
  end
end
#+END_SRC
***** (18) Merge Two Sorted Lists
#+BEGIN_SRC ruby
class LinkedList
  #HINT: This method builds new nodes.
  #TODO: Implement a method that reuses nodes.
  def merge_sorted(other)
    new_list = LinkedList.new
    current_other = other.head
    current_this = self.head
    while current_other != nil and current_this != nil
      if current_this.data < current_other.data
        new_list.append(current_this.data)
        current_this = current_this.next
      else
        new_list.append(current_other.data)
        current_other = current_other.next
      end
    end
    if current_other
      while current_other != nil
        new_list.append(current_other.data)
        current_other = current_other.next
      end
    end
    if current_this
      while current_this != nil
        new_list.append(current_this.data)
        current_this = current_this.next
      end
    end
    new_list
  end
end
#+END_SRC
***** (20) Insert value in a sorted way
start: 9:57
end: 10:09
#+BEGIN_SRC ruby
class LinkedList
  def insert_ordered(key)
    node = Node.new(key)
    prev = nil
    current = self.head
    while current != nil
      if current.data > key
        if current == self.head
          node.next = current
          self.head = node
        else
          prev.next = node
          node.next = current
        end
        break
      end
      prev = current
      current = current.next
    end
    if current.nil? and prev.nil?
      self.head = node
    elsif current.nil? and !prev.nil?
      prev.next = node
    end
  end
end
#+END_SRC 
***** (21) Delete a given node
start: 10:09
end: 10:26
#+BEGIN_SRC ruby
class LinkedList
  def delete_ordered(node)
    prev = nil
    current = self.head
    while current != nil
      if current == node
        if current == self.head
          self.head = current.next
        else
          prev.next = current.next
        end
        current = nil
        break
      end
      prev = current
      current = current.next
    end
  end
end
#+END_SRC
#+BEGIN_SRC ruby
#TODO: Talk to Manoj about this
class LinkedList
  def delete_node(node)
    if node.next.nil?
      node = nil
    else
      node.data = node.next.data
      node.next = node.next.next
    end
  end
end
#+END_SRC
***** (22) Check if list is palindrome
start: 10:27
end: 10:35
#+BEGIN_SRC ruby
class LinkedList
  def palindrome?
    stack = []
    current = self.head
    while current != nil
      stack.push current.data
      current = current.next
    end
    return false if stack.empty?

    current = self.head
    palindrome = true
    while !stack.empty?
      value = stack.pop
      if current.data != value
        palindrome = false
        break
      end
      current = current.next
    end
    palindrome
  end
end
#+END_SRC

start: 10:40
end: 11:33
#+BEGIN_SRC ruby
class LinkedList
  def size
    current = self.head
    counter = 0
    while current != nil
      counter = counter + 1
      current = current.next
    end
    counter
  end

  def reverse_from(key_index)
    prev = nil
    next_node = nil
    current = self.head
    index = 0
    while index != key_index - 1
      index = index + 1
      current = current.next
    end
    head = current
    prev = current
    current = current.next
    while current != nil
      next_node = current.next
      if head == prev
        current.next = nil
      else
        current.next = prev
      end
      prev = current
      current = next_node
    end
    head.next = prev
  end

  def palindrome_wo_stack?
    return false if size < 2

    mid = (size/2.to_f).ceil
    reverse_from mid
    second_current = self.head
    index = 0
    while index != mid
      index = index + 1
      second_current = second_current.next
    end
    palindrome = true
    current = self.head
    while second_current != nil
      if current.data != second_current.data
        palindrome = false
        break
      end
      second_current = second_current.next
      current = current.next
    end
    palindrome
  end
end
#+END_SRC

***** (23) Intersection Point of two lists
start: 11:35
end: 11:44
#+BEGIN_SRC ruby
#TODO: Discuss about a better way of implementing this
class LinkedList
  def intersection_point(other)
    nodes = {}
    current = self.head
    while current != nil
      nodes[current] = true
      current = current.next
    end
    current = other.head
    while current != nil
      if nodes.has_key?(current)
        break
      end
      nodes[current] = true
      current = current.next
    end
    current
  end
end
#+END_SRC
***** (24) Print Reverse
start: 12:25
end: 12:28
#+BEGIN_SRC ruby
class LinkedList
  def print_reverse(current = self.head)
    if current != nil
      print_reverse(current.next)
      puts current.data
    end
  end
end
#+END_SRC
***** (25) Remove duplicates sorted lists
start: 12:29
end: 12:40
#+BEGIN_SRC ruby
class LinkedList
  def remove_duplicates_sorted
    current = self.head
    next_node = nil
    while current != nil and current.next != nil
      next_node = current.next
      if current.data == next_node.data
        current.next = next_node.next
        next_node = nil
      else
        current = current.next
      end
    end
  end
end
#+END_SRC
***** (26) Remove duplicates unsorted lists
start: 12:42
end: 12:50
#+BEGIN_SRC ruby
class LinkedList
  def remove_duplicates_unsorted
    prev = nil
    current = self.head
    values = {}
    while current != nil
      next_node = current.next
      if values.has_key?(current.data)
        prev.next = current.next
      else
        values[current.data] = true
        prev = current
      end
      current = prev.next
    end
  end
end
#+END_SRC
***** (27) Pairwise swap elements
start: 3:46
end: 4:11
#+BEGIN_SRC ruby
class LinkedList
  def pairwise
    prev = nil
    next_node = nil
    current = self.head
    while current != nil and current.next != nil
      next_node = current.next
      current.next = next_node.next
      next_node.next = current
      if prev.nil?
        self.head = next_node
      else
        prev.next = next_node
      end
      prev = current
      current = current.next
    end
  end
end
#+END_SRC
***** (28) Practice questions about recursion
  - 1 -> prints the list in reverse order
  - 2 -> prints the elements of the list that are in an even position; it prints the elements twice.
***** (29) Move last element to the front
start: 4:19
end: 4:23
#+BEGIN_SRC ruby
class LinkedList
  def move_last_ele_to_the_front
    return if self.head.nil? || self.head.next.nil?

    prev = nil
    current = self.head
    while current.next != nil
      prev = current
      current = current.next
    end
    prev.next = nil
    current.next = self.head
    self.head = current
  end
end
#+END_SRC
***** (30) Intersection set of two lists
start: 4:24
end: 4:41
#+BEGIN_SRC ruby
class LinkedList
  def intersection_set(other)
    new_list = LinkedList.new
    first = self.head
    second = other.head
    while first != nil and second != nil
      if first.data == second.data
        new_list.append(first.data)
        first = first.next
        second = second.next
      elsif first.data < second.data
        first = first.next
      else
        second = second.next
      end
    end
    new_list
  end
end
#+END_SRC
***** (31) Delete Alternate Nodes
start: 4:44
end: 4:50
#+BEGIN_SRC ruby
class LinkedList
  def alternate_nodes
    current = self.head
    while current != nil and current.next != nil
      tmp = current.next
      current.next = tmp.next
      tmp = nil
      current = current.next
    end
  end
end
#+END_SRC
***** (32) Alternating Split
start: 4:50
end: 5:00
#+BEGIN_SRC ruby
class LinkedList
  def alternating_split
    first_list = LinkedList.new
    second_list = LinkedList.new
    if self.head.next == nil
      return [first_list.append(self.head), second_list]
    end

    first = self.head
    second = self.head.next
    while second != nil
      first_list.append(first.data)
      second_list.append(second.data)
      first = second.next
      second = first.next
    end
    if first
      first_list.append(first.data)
    end
    [first_list, second_list]
  end
end
#+END_SRC
***** (33) Identical Lists
start: 5:01
end: 5:06
#+BEGIN_SRC ruby
class LinkedList
  def identical?(other)
    identical = true
    first = self.head
    second = other.head
    while first != nil and second != nil
      if first.data != second.data
        identical = false
        break
      end
      first = first.next
      second = second.next
    end
    first.nil? and second.nil? ? identical : !identical
  end
end
#+END_SRC
***** (34) Merge Sort for Linked Lists
start: 5:11
end: 5:39
#+BEGIN_SRC ruby
class LinkedList
  def mid_node(first, last)
    slower = first
    faster = first
    while faster != last and faster.next != last
      slower = slower.next
      faster = faster.next.next
    end
    slower
  end

  def merge_sort(first, last)
    return LinkedList.new(Node.new(first.data)) if first == last

    middle_point = mid_node(first, last)
    left = merge_sort(first, middle_point).head
    right = merge_sort(middle_point.next, last).head
    new_list = LinkedList.new
    while left != nil or right != nil
      if left and right
        if left.data < right.data
          new_list.append(left.data)
          left = left.next
        else
          new_list.append(right.data)
          right = right.next
        end
      elsif left
        new_list.append(left.data)
        left = left.next
      elsif right
        new_list.append(right.data)
        right = right.next
      end
    end
    new_list
  end
end
#+END_SRC
***** (35) Reverse Linked List in groups of given size
start: 5:41
end: 7:05
#+BEGIN_SRC ruby
class LinkedList
  def reverse(prev_node, start_node, next_to_end_node)
    prev = prev_node
    current = start_node
    while current != next_to_end_node
      next_node = current.next
      current.next = prev
      prev = current
      current = next_node
    end
    start_node.next = next_to_end_node
  end

class LinkedList
  def reverse_groups(group_size)
    start_node = self.head
    end_node = start_node
    next_node = nil
    prev = nil
    while start_node != nil && start_node.next != nil
      current_size = 1
      while current_size != group_size and end_node != nil
        end_node = end_node.next
        current_size = current_size + 1
      end
      break if end_node.nil?

      next_node = end_node.next

      tmp_current = start_node
      tmp_next_node = nil
      tmp_prev = prev
      while tmp_current != next_node
        tmp_next_node = tmp_current.next
        tmp_current.next = tmp_prev
        tmp_prev = tmp_current
        tmp_current = tmp_next_node
      end
      start_node.next = next_node

      if prev.nil?
        self.head = end_node
      else
         prev.next = end_node
      end
      prev = start_node
      start_node = next_node
      end_node = next_node
    end
  end
end
#+END_SRC
***** 51
***** 69
***** 15
***** 29
***** 15
***** 60

*** Circular Linked List
Elements are connected to form a circle
**** Advantages
- Any node can be the starting point
- Queue can be implemented by using CircularLinkedList
  - Front can be always be reached from the next of the last node added
- It's useful if you have to go repeatedly over the list
**** Traversal
#+BEGIN_SRC ruby
def print_list(node)
  current = node
  loop do
    print current.data
    current = current.next
    break if current == node
  end
end
[1]->[2]->[3]--|
 ^             |
 |=============|
#+END_SRC
*** Doubly Linked List
**** Advantages
  - It can be traversed both ways
  - Delete operation is more efficient if pointer to the node is given
**** Disavantages over LinkedList
  - An extra pointer is needed
  - prev pointer needs to be maintain
**** Structure
#+BEGIN_SRC ruby
class Node
  attr_accessor :data, :prev, :next
  def initialize(data, next_node=nil, prev=nil)
    self.data = data
    self.next = next_node
    self.prev = prev
  end
end

class DoublyLinkedList
  attr_accessor :head
  def initialize(node)
    self.head = node
  end
end
#+END_SRC
**** Insertion
#+BEGIN_SRC ruby
class DoublyLinkedList
  def push(data)
    node = Node.new(data, self.head)
    self.head.prev = node
    self.head = node
  end

  def append(data)
    current = self.head
    while current.next != nil
      current = current.next
    end
    node = Node.new(data)
    node.prev = current
    current.next = node
  end

  def insertAfter(data, node)
    new_node = Node.new(data, node.next, node)
    node.next.prev = new_node
    node.next = new_node
  end

  def insertBefore(data, node)
    new_node = Node.new(data, node, node.prev)
    node.prev.next = new_node
    node.prev = new_node
  end

  def printAll
    current = self.head
    while current != nil
      puts current.data
      current = current.next
    end
  end
end
#+END_SRC
**** Reverse
#+BEGIN_SRC ruby
class DoublyLinkedList
  def reverse
    current = self.head
    temp = nil
    loop do
      temp = current.prev
      current.prev = current.next
      current.next = temp
      current = current.prev
      break if current == nil
    end
    if temp != nil
      self.head = temp.prev
    end
  end
end
H
| -> ->
V
1  2  3
 <- <-
      H
 <- <-|
      V
1  2  3
 -> ->

nil <- 1 -> 2
2   <- 1 -> nil

#+END_SRC
*** Stack
Stack can be implemented by an array or linked list.
**** Purpose
  - Mantaining Function Calls
  - Recursion can be removed by using stacks
  - Reversing words
  - Balanced parenthesis
  - Undo operations (last operation)
  - Implement back functionality in a browser
**** Exercises
***** (3) Evaluate a postfix expresion
#+BEGIN_SRC ruby
#2 3 1 * + 9 -
def eval_postfix(postfix_str)
  stack = []
  postfix_str.split(" ").each do |char|
     if char =~ /[0-9]+/
       stack.push char.to_i
     else
       second = stack.pop
       first = stack.pop
       stack.push first.public_send(char, second)
     end
  end
  stack.pop
end
#+END_SRC
***** (4) Reverse a string
#+BEGIN_SRC ruby
def reverse(str)
  stack = []
  str.split("").each do |char|
    stack.push char
  end
  acc = ""
  while !stack.empty?
    acc = acc + stack.pop
  end
  acc
end
#+END_SRC
***** (5) Implement Two stacks in an Array
start: 7:00
end: 7:22
#+BEGIN_SRC ruby
class TwoStacks
  attr_accessor :arr, :indexes, :max_size
  def initialize(max_size=50)
    self.arr = Array.new(max_size)
    self.indexes = [-1, max_size]
    self.max_size = max_size
  end

  def _push(ele, left, right, op1, op2)
    return if self.indexes[left] == self.indexes[right].send(op1, 1)
    self.indexes[left] = self.indexes[left].send(op2, 1)
    self.arr[self.indexes[left]] = ele
  end

  def push1(ele)
    _push(ele, 0, 1, '-', '+')
  end

  def push2(ele)
    _push(ele, 1, 0, '+', '-')
  end

  def _pop(index, lower_boundary)
    return if self.indexes[index] == lower_boundary
    ele = self.arr[self.indexes[index]]
    self.arr[self.indexes[index]] = nil
    self.indexes[index] = self.indexes[index] - 1
    ele
  end

  def pop1
    _pop(0, -1)
  end

  def pop2
    _pop(1, self.max_size)
  end
end
#+END_SRC
***** (6) Balanced Parentheses
start: 7:47
end: 7:54
#+BEGIN_SRC ruby
def balanced_parentheses?(str)
  stack = []
  str.split("").each do |char|
    case char
      when "]"
        top = stack.pop
        break if top != "["
      when ")"
        top = stack.pop
        break if top != "("
      when "}"
        top = stack.pop
        break if top != "{"
      else
        stack.push(char)
    end
  end
  stack.empty?
end
#+END_SRC
***** (7) Next Greater Element
start: 7:55
end: 9:32
#+BEGIN_SRC ruby
def next_greater2(numbers)
  stack = []
  numbers.each do |number|
    if stack.empty?
      stack.push [number, -1]
    else
      top_ele, top_greater = stack[-1]
      if number > top_ele
        aux_stack = []
        loop do
          ele, greater = stack[-1]
          break if greater != -1 or ele > number
          ele, greater = stack.pop
          aux_stack.push [ele, number]
        end
        while !aux_stack.empty?
          stack.push aux_stack.pop
        end
      end
      stack.push [number, -1]
    end
  end
  while !stack.empty?
    ele, greater = stack.pop
    puts "#{ele}, #{greater}"
  end
end
#+END_SRC
***** (8) Reverse a stack using recursion
start: 4:38 5:02
end: 
#+BEGIN_SRC ruby
def reverse_stack(stack, result=[])
  if stack.empty?
    return result
  end
  result.push stack.pop
  reverse_stack(stack, result)
end
#+END_SRC
***** (9) Sort a stack using recursion
start: 5:03
end: 5:30
#+BEGIN_SRC ruby
def main(stack)
  repeat(stack.size, 0, stack)
end

def repeat(times, index, sorted_stack)
  return sorted_stack if times == index
  sorted_stack = sort_stack_recursion(sorted_stack)
  repeat(times, index+1, sorted_stack)
end

def sort_stack_recursion(stack)
  return stack if stack.size == 1
  tmp = stack.pop
  sorted_stack = sort_stack_recursion(stack)
  if tmp < sorted_stack[-1]
    ele = sorted_stack.pop
    sorted_stack.push tmp
    sorted_stack.push ele
  else
    sorted_stack.push tmp
  end
  sorted_stack
end
#+END_SRC
***** (10) Stock Span Problem
start: 5:32
end: 5:46
https://www.youtube.com/watch?v=LvQzYMXEANs
#+BEGIN_SRC ruby
def WRONG_stock_span(prices)
  stack = [prices.first]
  results = [1]
  index = 1
  prices[1..-1].each do |price|
    tmp_stack = []
    counter = 1
    while !stack.empty?
      ele = stack.pop
      if price >= ele
        counter = counter + 1
      end
      tmp_stack.push ele
    end
    while !tmp_stack.empty?
      stack.push tmp_stack.pop
    end
    results[index] = counter
    index = index + 1
    stack.push price
  end
  results
end

def stock_span(prices)
  stack = [0]
  spans = [1]
  index = 1
  max = prices.size
  while index != max
    while !stack.empty? && prices[index] > prices[stack[-1]]
      stack.pop
    end
    if stack.empty?
      h = -1
    else
      h = stack[-1]
    end
    spans[index] = index - h
    stack.push index
    index = index + 1
  end
  spans
end
#+END_SRC
***** (11) Design and Implement Special Stack
start: 7:11
end: 7:29
#+BEGIN_SRC ruby
class SpecialStack
  attr_accessor :elements, :mins, :capacity, :current_size
  def initialize(capacity)
    self.elements = []
    self.mins = []
    self.capacity = capacity
    self.current_size = 0
  end

  def push(ele)
    return if isFull
    self.elements.push ele
    if self.mins.empty?
      self.mins.push ele
    elsif ele < self.mins[-1]
      self.mins.push ele
    end
    self.current_size += 1
  end

  def pop
    return if isEmpty
    ele = self.elements.pop
    if ele == self.mins[-1]
      self.mins.pop
    end
    ele
  end

  def isEmpty
    self.current_size == 0
  end

  def isFull
   self.capacity == self.current_size
  end

  def getMin
    self.mins[-1]
  end
end
#+END_SRC
***** (12) Implement a Stack by using queue
start: 7:30
end:
#+BEGIN_SRC ruby
class MyStack
  attr_accessor :front, :bottom
  def initialize
    self.front = Queue.new
    self.bottom = Queue.new
  end

  def push(ele)
    if self.front.empty?
      self.front.enq ele
    else
      front = self.front.pop
      self.bottom.enq front
      self.front.enq ele
    end
  end

  def pop
    if self.front.size == 1
      self.front.pop
    elsif self.front.empty?
      while self.bottom.size > 1
        self.front.enq self.bottom.pop
      end
      self.bottom.pop
    end
  end
end
#+END_SRC
***** (13) Stack with operations in the middle
start: 5:20
end: 5:54
start_2: 8:40
end_2: 9:37
#+BEGIN_SRC ruby
#array cannot be used
class WRONG_ArrayStackMiddle
  attr_accessor :array, :size
  def initialize
    self.array = []
    self.size = 0
  end

  def push(ele)
    self.array.push ele
    self.size = self.size + 1
  end

  def pop()
    if !self.array.empty?
      while self.array[-1] ! nil
        self.array.pop
      end
      self.size = self.size - 1
      self.array.pop
    end
  end

  def middle()
    (self.size / 2.to_f).floor
  end

  def find_middle()
    self.array[self.middle]
  end

  def delete_middle()
    self.array[self.middle] = nil
  end
end

class Node
  attr_accessor :data, :next, :prev
  def initialize(data)
    self.data = data
  end
end

class DoublyLinkedListStack
  attr_accessor :head, :middle_node, :size, :middle_index
  def initialize
    self.head = self.middle_node = nil
    self.size = self.middle_index = 0
  end

  def push(ele)
    node = Node.new(ele)
    self.size = self.size + 1
    if !self.head.nil?
      node.next = self.head
      self.head.prev = node
    end
    self.head = node
    #START: move middle
    if self.head.next.nil?
      self.middle_node = self.head
      self.middle_index = self.size
    else
      new_middle_index = (self.size / 2.to_f).ceil
      return if self.middle_index == new_middle_index
      if new_middle_index > self.middle_index
        self.middle_index = new_middle_index
        self.middle_node = self.middle_node.prev
      end
    end
    #END: move middle
  end

  def pop()
    return if self.head.nil?

    data = self.head.data
    new_head = self.head.next
    new_head.prev = nil if new_head
    self.head.next = nil
    self.head = new_head
    self.size = self.size - 1
    #START: move middle
    new_middle_index = (self.size / 2.to_f).ceil
    if self.middle_index == new_middle_index
      self.middle_node = self.middle_node.prev
    elsif new_middle_index < self.middle_index
      self.middle_index = new_middle_index
      self.middle_node = self.middle_node.next
    end
    #END: move middle
    data
  end

  def find_middle()
    self.middle_node.data if self.middle_node
  end

  def delete_middle()
    return if self.middle_node.nil?
    self.size = self.size - 1
    if self.middle_node.prev
      self.middle_node.prev.next = self.middle_node.next
    end
    if self.middle_node.next
      self.middle_node.next.prev = self.middle_node.prev
    end

    return if self.head.nil?
    #START: move middle
    new_middle_index = (self.size / 2.to_f).ceil
    if self.middle_index == new_middle_index
      self.middle_node = self.middle_node.prev
    elsif new_middle_index < self.middle_index
      self.middle_index = new_middle_index
      self.middle_node = self.middle_node.next
    end
    #END: move middle
  end
end
#+END_SRC
***** (14) How to efficiently implement k stacks in a single array
start: 3:30
end: 4:30

top always refers to two positions:
  - arr; if top points to 8, then arr[8] contains the element
  - next; if top points to 8, then next[8] contains the *index* to the next node.

#+BEGIN_SRC ruby
class KArrayStack
  attr_accessor :arr, :top_arr, :next_arr, :free
  def initialize(k, capacity = 6)
    self.arr = Array.new(capacity)
    self.top_arr = Array.new(k, -1)
    self.next_arr = Array.new(capacity, -1)
    (0..capacity-2).each do |index|
      self.next_arr[index] = index + 1
    end
    self.free = 0
  end

  def push(ele, k)
    return if self.free == -1
    i = self.free
    self.free = self.next_arr[i]
    self.next_arr[i] = self.top_arr[k]
    self.top_arr[k] = i
    self.arr[i] = ele
  end

  def pop(k)
    return if self.top_arr[k] == -1

    ele = self.arr[self.top_arr[k]]
    self.arr[self.top_arr[k]] = nil
    i = self.free
    self.free = self.top_arr[k]
    self.top_arr[k] = self.next_arr[self.free]
    self.next_arr[self.free] = i
    ele
  end
end
#+END_SRC
***** (16) Length of the longest valid substring
start: 4:38
end: 4:47
#+BEGIN_SRC ruby
#HINT: Discuss this with Manoj
def length_longest_substring(str)
  stack = []
  counter = 0
  str.split("").each do |char|
    if char == ')' && stack[-1] == '('
      counter = counter + 2
      stack.pop
    else
      stack.push char
    end
  end
  counter
end
#+END_SRC
***** (17) Find maximum of minimum for every window size in a given array
start: 6:26
end: 7:12
#+BEGIN_SRC ruby
def max_of_the_min_window_o_n3(numbers)
  size = 1
  super_group = []
  while size != numbers.size + 1
    groups = []
    index = 0
    while index != numbers.size
      sub_index = index
      group = []
      while group.size != size && sub_index != numbers.size
        group << numbers[sub_index]
        sub_index = sub_index + 1
      end
      groups << group if group.size == size
      index = index + 1
    end
    super_group << groups.map{|group| group.min}.max
    size = size + 1
  end
  super_group
end

def max_of_the_min_window(numbers)
  groups = []
  index = 0
  while index != numbers.size
    groups << []
    index = index + 1
  end
  index = 0
  while index != numbers.size
    sub_index = 0
    while sub_index != index + 1
      groups[sub_index] << numbers[(index - sub_index)..index]
      sub_index = sub_index + 1
    end
    index = index + 1
  end
  groups.map{|group| group.map{|sub| sub.min}.max}
end

numbers = [10, 20, 30, 50, 10, 70, 30] * 10000;1
Benchmark.bm do |x|
  x.report { max_of_the_min_window numbers }
  x.report { max_of_the_min_window_o_n3 numbers }
end
#+END_SRC
*** Queue
Queue can be implemented by an array or linked list.
**** Purpose
  - Collection of Elements First In, First Out
  - Operations
    - enqueue -> element added to the "rear"
    - dequeue -> element removed from the "front"
  - When data is transferred asynchronously
    - IO Buffers, Pipes, File IO
  - Breadth-First Search
  - CPU Scheduling, Disk Scheduling
**** Exercises
***** (1) Implement a Queue by using an Array
start: 7:25
end: 7:51
#+BEGIN_SRC ruby
class ArrayQueue
  attr_accessor :arr, :top, :free, :capacity
  def initialize(capacity = 50)
    self.arr = Array.new(capacity, nil)
    self.top = -1
    self.free = 0
    self.capacity = capacity
  end

  def front
    return if self.top == -1
    self.arr[self.top]
  end

  def enqueue(ele)
    return if self.top == self.free

    self.arr[self.free] = ele
    if self.top == -1
      self.top = self.free
    end
    self.free = (self.free + 1) % self.capacity
  end

  def dequeue
    return if self.top == -1

    ele = self.arr[self.top]
    self.arr[self.top] = nil
    self.top = (self.top + 1) % self.capacity
    if self.top == self.free
      self.top = -1
    end
    ele
  end
end
#+END_SRC
***** (2) Implement a Queue by using a LinkedList
start: 7:54
end: 8:06
#+BEGIN_SRC ruby
class Node
  attr_accessor :data, :next
  def initialize(data, next_node=nil)
    self.data = data
    self.next = next_node
  end
end

class LinkedListQueue
  attr_accessor :front, :rear
  def initialize
    self.front = self.rear = nil
  end

  def enqueue(ele)
    node = Node.new(ele)
    if self.front.nil?
      self.front = node
      self.rear = node
    else
      self.rear.next = node
      self.rear = node
    end
  end

  def dequeue
    return if self.front.nil?
    node = self.front
    self.front = self.front.next
    data = node.data
    node = nil
    data
  end
end
#+END_SRC
***** (3) Applications of Queue Data Structure
No exercises
***** (4) Priority Queue Implementation
  - Every item has a priority
  - Element with high priority is dequeued before an element with low priority
  - If two elements have the same priority, they are served according to their order in the queue
  - Applications
    - CPU Scheduling
    - All queue applications where priority is involved
***** (5) Deque or Double Ended Queue
  - Implementations
    - Doubly Linked List
    - Circular Array
***** (6) [READ AGAIN]Implementation of Deque using Circular Array
start: 5:15
end: 6:21
#+BEGIN_SRC ruby
class DequeCircularArray
  attr_accessor :arr, :front, :rear, :capacity
  def initialize(capacity)
    self.capacity = capacity
    self.arr = Array.new(self.capacity, nil)
    self.front = 0
    self.rear = 0
  end

  def insert_front(ele)
    return if is_full?
    if is_empty?
      self.arr[self.front] = ele
    else
      self.front = (self.front - 1) % self.capacity
      self.arr[self.front] = ele
    end
  end

  def insert_rear(ele)
    return if is_full?
    if is_empty?
      self.front = self.rear = 0
      self.arr[self.front] = ele
    else
      self.rear = (self.rear + 1) % self.capacity
      self.arr[self.rear] = ele
    end
  end

  def delete_front
    return if is_empty?
    self.arr[self.front] = nil
    if self.front == self.rear
      self.front = (self.front + 1) % self.capacity
      self.rear = self.front
    else
      self.front = (self.front + 1) % self.capacity
    end
  end

  def delete_rear
    return if is_empty?
    self.arr[self.rear] = nil
    if self.rear == self.front
      self.rear = (self.rear - 1) % self.capacity
      self.front = self.rear
    else
      self.rear = (self.rear - 1) % self.capacity
    end
  end

  def get_front
    return if is_empty?
    self.arr[self.front]
  end

  def get_rear
    return if is_empty?
    self.arr[self.rear]
  end

  def is_empty?
    self.arr[self.front].nil? && self.arr[self.rear].nil?
  end

  def is_full?
    (self.front - 1) % self.capacity == self.rear
  end
end
#+END_SRC
***** (7) [READ AGAIN]Implement Queue Using Stacks
start: 8:22
end: 8:29
#+BEGIN_SRC ruby
class QueueStacks
  attr_accessor :front_stack, :rear_stack
  def initialize
    self.front_stack = []
    self.rear_stack = []
  end

  def enqueue(ele)
    if self.front_stack.empty? && self.rear_stack.empty?
      self.front_stack.push ele
    else
      self.rear_stack.push ele
    end
  end

  def dequeue
    if !self.front_stack.empty?
      ele = self.front_stack.pop
    else
      while !self.rear_stack.empty?
        self.front_stack.push self.rear_stack.pop
      end
      ele = self.front_stack.pop
    end
    ele
  end
end
#+END_SRC
***** (8) [READ AGAIN]Check whether a binary tree is complete or not
start: 6:03
end: 7:45
#+BEGIN_SRC ruby
#HINT: I used the concept of levels, but that complicated things *a lot*
#Using the concept of Full Node(right && left != null) simplifies everything!
class MyNode
  attr_accessor :data, :left, :right
  def initialize(data, left=nil, right=nil)
    self.data = data
    self.left = left
    self.right = right
  end
end

def is_complete?(binary_tree)
  queue = []
  current_level = 0
  next_level = nil
  queue.push [binary_tree, 0]
  current_total = 0
  complete = true
  more_children_allowed = true
  while !queue.empty? do
    expected_total = 2**current_level
    current_total = 0
    next_level = current_level + 1
    while !queue.empty? && queue[0][1] != next_level do
      current_total = current_total + 1
      ele, current_level = queue.shift
      puts "#{!ele.right.nil?}, #{ele.left.nil?}"
      if !ele.right.nil? && ele.left.nil?
        complete = false
        break
      end
      if current_total == 1 && ele.left.nil?
        more_children_allowed = false
      end
      if (ele.right || ele.left) && !more_children_allowed
        complete = false
        break
      end
      queue.push [ele.left, next_level] if ele.left
      queue.push [ele.right, next_level] if ele.right
    end
    current_level = next_level
    break if complete == false
    if current_total != expected_total && more_children_allowed == true
      complete = false
      break
    end
  end
  complete
end
#+END_SRC
***** (10) [IMPLEMENT IT AGAIN]Find the first circular tour that visits all petrol pumps
runtime complexity: O(n)
extra space: O(n);;it should be posible O(1)
#+BEGIN_SRC ruby
class PetrolPump
  attr_accessor :petrol, :distance
  def initialize(petrol, distance)
    self.petrol = petrol
    self.distance = distance
  end
end

def circular_tour(pumps)
  good_pumps = []
  bad_pumps = []
  gas = 0
  current = 0
  while current < pumps.size
    if gas + pumps[current].petrol - pumps[current].distance > 0
      good_pumps.append current
      gas = gas + pumps[current].petrol - pumps[current].distance
    else
      while !good_pumps.empty?
        bad_pumps.append good_pumps.shift
      end
      bad_pumps.append current
    end
    current = current + 1
  end
  found = true
  while !bad_pumps.empty?
    current = bad_pumps.shift
    if gas + pumps[current].petrol - pumps[current].distance > 0
      good_pumps.append current
      gas = gas + pumps[current].petrol - pumps[current].distance
    else
      found = false
      break
    end
  end
  if found
    good_pumps[0]
  else
    -1
  end
end
#+END_SRC
***** (11) Sliding Window Maximum (Maximum of all subarrays of size k)
#+BEGIN_SRC ruby
def sliding_window_maximum(arr, k)
  deque = []
  (0..k-1).each do |index|
    while !deque.empty? && arr[index] > deque[-1]
      deque.pop
    end
    deque.push(index)
  end
  index = k
  while index != arr.size
    puts arr[deque[0]]
    while !deque.empty? && deque[0] <= index - k
      deque.shift
    end
    while !deque.empty? && arr[index] > arr[deque[-1]]
      deque.pop
    end
    deque.append(index)
    index = index + 1
  end
  puts arr[deque[0]]
end
#+END_SRC

** Tree Based
*** Binary Search Tree
**** Structure
#+BEGIN_SRC r
uby
class Node
  attr_accessor :data, :left, :right
  def initialize(data, left=nil, right=nil)
    self.data = data
    self.left = left
    self.right = right
  end
end

class BinarySearchTree
  attr_accessor :root, :prev, :side
  def initialize(root=nil)
    self.root = root
    self.prev = nil
    self.side = nil
  end
end
#+END_SRC
**** Operations
***** Node Deletion
Three Cases:
  1. Node to be deleted is a leaf
  2. Node to be deleted has a right children
  3. Node to be deleted has a left children but does not have a right children

- For (1); Free the pointer to the node. Done.
- For (2); Keep a reference to the node that will be deleted; Find the minimum element that belongs to the *right* subtree; Once you find the minimum node, interchange the values; call delete method again but now pass the reference to the minimum node.
- For (3); Keep a reference to the node that will be deleted; Find the maximum element that belongs to the *left* subtree; Once you find the minimum node, interchange the values; call delete method again but now pass the reference to the maximum node.
#+BEGIN_SRC ruby
class BinarySearchTree
  def find_node(key)
    current = self.root
    self.prev = nil
    node = nil
    while !current.nil?
      if current.data == key
        node = current
        break
      elsif key > current.data
        self.prev = current
        self.side = :right
        current = current.right
      else
        self.prev = current
        self.side = :left
        current = current.left
      end
    end
    node
  end

  def delete_node(key)
    current = self.find_node(key)
    while !current.nil?
      if current.data == key && current.right.nil? && current.left.nil?
        self.prev.send("#{self.side}=", nil)
        break
      elsif current.data == key && !current.right.nil?
        minimum = self.find_minimum(current.right)
        self.prev = current
        self.side = :right
        current.data = minimum.data
        current = minimum
        key = minimum.data
      else
        maximum = self.find_maximum(current.left)
        self.prev = current
        self.side = :left
        current.data = maximum.data
        current = maximum
        key = maximum.data
      end
    end
  end

  def find_minimum(node)
    self.prev = nil
    self.side = nil
    current = node
    while !current.nil? && !current.left.nil?
      self.prev = current
      self.side = :left
      current = current.left
    end
    current
  end

  def find_maximum(node)
    self.prev = nil
    self.side = nil
    current = node
    while !current.nil? && !current.right.nil?
      self.prev = current
      self.side = :right
      current = current.right
    end
    current
  end
end
#+END_SRC

*** Heap
**** Properties
In the binary tree implementation the following properties must be observed:
- It's a complete tree (all levels are filled except the last)
- Leaves are allocated as left as possible
- Min heap and Max heap can be efficiently implemented by using a binary tree
- If Min Heap, the root is the smallest element in the collection. This applies to all subtrees
- If Max Heap, the root is the greates element in the collection. This applies to all subtrees
**** Structure
It's observed that a complete tree can be implemented by using an array:
| root | parent node | left node | right node |
|------+-------------+-----------+------------|
|    0 | i/2         | 2*i + 1   | 2*i + 2    |
#+BEGIN_SRC ruby
class MinHeap
  attr_accessor :max, :index, :tree
  def initialize(max=10)
    self.index = 0
    self.max = max + 1
    self.tree = Array.new(self.max)
  end
end
#+END_SRC
**** Operations
***** Addition
Inserts the new element at the end; if the element is greater than its parent interchange them; done otherwise
#+BEGIN_SRC ruby
class MinHeap
  def add(element)
    return if self.index == self.max - 1
    self.index = self.index + 1
    self.tree[self.index] = element
    heapify_up
  end

  def heapify_up
    index = self.index
    while index > 1
      parent_node = index/2
      break if self.tree[index] > self.tree[parent_node]

      tmp = self.tree[parent_node]
      self.tree[parent_node] = self.tree[index]
      self.tree[index] = tmp
      index = parent_node
    end
  end
end
#+END_SRC
***** Deletion
Override the value of root with the last value of the tree; check that root is the smallest element in the tree;
if not, rotate from with the smallest; keep doing that until the condition is false.
#+BEGIN_SRC ruby
class MinHeap
  def delete
    return if self.index == 0
    top = self.tree[1]
    self.tree[1] = self.tree[self.index]
    self.index = self.index - 1
    heapify_down
    top
  end

  def heapify_down
    index = 1
    while index < self.index - 1
      break if self.tree[index] < self.tree[2*index]
      tmp = self.tree[index]
      if self.tree[2*index] > self.tree[2*index + 1]
        self.tree[index] = self.tree[2*index + 1]
        self.tree[2*index + 1] = tmp
        index = 2*index + 1
      else
        self.tree[index] = self.tree[2*index]
        self.tree[2*index] = tmp
        index = 2*index
      end
    end
  end
end
#+END_SRC
**** Application
- Heap Sort
- Priority Queue
* Exercises
** Array and String
** Exercises [8/9]
  - [X] *Is Unique*: Implement an algorithm to determine if a string has
    all unique  characters.  What  if you  cannot use  additional data
    structures?
    1. This  solution is ~O(len(string) +  len(letters.values))~, thus
       ~O(n)~.   I  am  making  the assumption  that  hash  access  is
       constant.
      #+BEGIN_SRC ruby
  def is_unique?(string)
    letters = Hash.new(0)
    string.each_char do |char|
      letters[char] += 1
    end
    letters.values.select{|counter| counter > 1}.empty?
  end
     #+END_SRC
    2. This solution is ~O(n * log(n) + n)~, thus ~O(n * log n)~.  I am
       assuming that I cannot use an additional data structure.
       #+BEGIN_SRC ruby
  def is_unique?(string)
    sorted_string = string.split(//).sort
    next_index = 1
    result = true
    sorted_string[0..-2].each do |char|
      if char == sorted_string[next_index]
	result = false
	break
      end
      next_index += 1
    end
    result
  end
       #+END_SRC

  - [X] *Check permutation* Given two strings write a method to decide
    if one is a permutation of the other.
    #+BEGIN_SRC ruby
    def permutation(s1, s2)
      new_s1 = s1.split(//)
      new_s2 = s2.split(//)
      store = {}
      new_s2.each do |char|
        store[char] = true
      end

      result = true
      new_s1.each do |char|
        if !store.has_key?(char)
          result = false
	  break
	end
      end
      result
    end
    #+END_SRC

  - [X] *URLify*
    The solution is ~O(n + n)~, this ~O(n)~.

    #+BEGIN_SRC ruby
def urilify(string_array, size)
  spaces_index = []
  string_array[0..(size - 1)].each_with_index do |char, index|
    spaces_index << index if char == " "
  end

  current_index = spaces_index.count * 2 + size - 1
  string_index = size - 1

  while(current_index >= 0) do
    if spaces_index.include?(string_index)
      string_array[current_index] = "0"
      string_array[current_index - 1] = "2"
      string_array[current_index - 2] = "%"
      current_index -= 3
    else
      string_array[current_index] = string_array[string_index]
      current_index -= 1
    end
    string_index -= 1
  end
  string_array
end
    #+END_SRC

  - [X] *Palindrome  Permutation*  Given  a  string,  check  if  any
    permutation of  it is a palindrome.   The solution I came  up is a
    recursive  solution,  and I'm  pretty  sure  that is  exponential.
    However I don't know how to prove that.
    #+BEGIN_SRC ruby
def remaining_array(init, array)
  size = array.count
  size.times.map do |index|
    i = (init + index) % size
    array[i]
  end[1..-1]
end


def permutation(array)
  return array if array.empty?
  return [array] if array.count == 1
  results = []
  array.each_with_index do |e, index|
    permutation(remaining_array(index, array)).each do |a|
      results << [e].concat(a)
    end
  end
  results
end

def palindrome?(array)
  left_index = 0
  right_index = -1
  flag = true
  limit = (array.size/2.to_f).ceil
  array.size.times do |index|
    if right_index.abs > limit
      break
    end

    if array[index] != array[right_index] && (!array[index].blank? && !array[right_index].blank?)
      flag = false
      break
    end
    right_index -= 1
  end
  flag
end

def is_palindrome(s1)
  array = s1.split(//)
  permutation(array).select{|a| palindrome?(a) == true}.any?
end
    #+END_SRC

  - [X] *One Away*
    Given two strings, write a function to check if they are one edit (or zero edits) away.
    #+BEGIN_SRC ruby
def is_one_away?(s1, s2)
  longest, shortest = s1.size > s2.size ? [s1, s2] : [s2, s1]
  counter = 0
  shortest_index = 0
  longest.split(//).each_with_index do |char, index|
    if char == shortest[shortest_index]
      shortest_index += 1
      next
    end

    if longest[index+1] == shortest[shortest_index]
      counter += 1
    elsif longest[index+1] == shortest[shortest_index+1]
      counter += 1
      shortest_index += 1
    end
  end
  counter <= 1 ? true : false
end

is_one_away?("pale", "ple") == true
is_one_away?("pales", "pale") == true
is_one_away?("pale", "bale") == true
is_one_away?("pale", "bake") == false
    #+END_SRC

  - [X] *String Compression*
    aabcccccaaa `->` a2b1c5a3
    #+BEGIN_SRC ruby
def compress(string)
  normalized_string = string.split(//)
  repetitions = 0
  previous = normalized_string[0]
  new_string = ""
  normalized_string.each do |char|
    if (char == previous)
      repetitions += 1
    else
      new_string += "#{previous}#{repetitions}"
      previous = char
      repetitions = 1
    end
  end
  if normalized_string[-1] == previous
    new_string += "#{previous}#{repetitions}"
  end
  new_string
end
    #+END_SRC

  - [ ] *Rotate Matrix*

  - [X] *Zero Matrix* Given a MxN matrix, write an algorithm such that
    if an element is 0, its entire row and columns are set to 0.
    #+BEGIN_SRC ruby
def zero_matrix(matrix, row_count, column_count)
  rows = []
  columns = []
  matrix.each_with_index do |row, row_index|
    row.each_with_index do |element, column_index|
      if element == 0
        rows << row_index
        columns << column_index
      end
    end
  end
  rows.uniq.each do |row_index|
    matrix[row_index] = column_count.times.map{|c| 0}
  end
  columns.uniq.each do |column_index|
    matrix.each do |row|
      row[column_index] = 0
    end
  end
  matrix
end

zero_matrix([[1, 2], [3, 4], [5, 0]], 3, 2) == [[1, 0], [3, 0], [0, 0]]
    #+END_SRC

  - [X] *String Rotation*
    "waterbottle" is a rotation of "erbottlewat"
    #+BEGIN_SRC ruby
    def is_rotation(s1, s2)
      "#{s2}#{s2}".include?(s1)
    end

    is_rotation("waterbottle", "erbottlewat") == true
    #+END_SRC
** Implementations
*** Hash Table
    - Compute key's hash code
    - Map the key's hash code to an index in the array
    - In that position we need to store the key and value
      - use a linked list
    - Is it possible to use a binary search tree?

      This implementation uses a linked list and a fixed size array
      #+BEGIN_SRC ruby
class Node
  attr_accessor :key, :value, :next_node
  def initialize(key, value, next_node = nil)
    self.key = key
    self.value = value
    self.next_node = next_node
  end
end

class EmptyNode
  attr_accessor :key, :value, :next_node
end

class LinkedList
  attr_accessor :first_node, :size

  def initialize(node = nil)
    node = node ? node : EmptyNode.new()
    self.first_node = node
    self.size = 1
  end

  def add(key, value)
    node = Node.new(key, value, self.first_node)
    self.first_node = node
    self.size += 1
    self
  end

  def find
    return if !block_given?

    current = self.first_node
    found = false
    self.size.times.each do
      found = yield current
      break if found
      current = current.next_node
    end
    current if found
  end
end

class MyHash
  attr_accessor :array, :size
  def initialize(size = nil)
    self.size = 50
    self.array = self.size.times.map do
      LinkedList.new()
    end
  end

  def add(key, value)
    hash_value = hash_for(key)
    array_index = hash_value % self.size
    self.array[array_index].add(key, value)
    self
  end

  def value(key)
    hash_value = hash_for(key)
    array_index = hash_value % self.size
    node = self.array[array_index].find do |node|
      node.key == key
    end
    node.value if node
  end

  private
  def hash_for(key)
    md5 = Digest::MD5.new
    md5.update(key.to_s).hexdigest.to_i
  end
end
      #+END_SRC

      This implementation is using BST
      #+BEGIN_SRC ruby
class TreeNode
  attr_accessor :key, :value, :left_node, :right_node
  def initialize(key, value, left_node = EmptyTreeNode.new, right_node = EmptyTreeNode.new)
    self.key = key
    self.value = value
    self.left_node = left_node
    self.right_node = right_node
  end

  def add(key, value)
    left_node = self.left_node
    right_node = self.right_node
    if key > self.key
      right_node = self.right_node.add(key, value)
    else
      left_node = self.left_node.add(key, value)
    end
    TreeNode.new(self.key, self.value, left_node, right_node)
  end

  def find_by(key)
    return self if key == self.key

    if key > self.key
      self.right_node.find_by(key)
    else
      self.left_node.find_by(key)
    end
  end
end

class EmptyTreeNode
  def add(key, value)
    TreeNode.new(key, value)
  end

  def find_by(key)
    self
  end

  def value
    nil
  end
end

class MyHashUsingBST
  attr_accessor :tree
  def initialize()
    self.tree = EmptyTreeNode.new
  end

  def add(key, value)
    self.tree = self.tree.add(key, value)
  end

  def value(key)
    self.tree.find_by(key).value
  end
end

m = MyHashUsingBST.new
m.add(:milton, 5)
m.add(:ivania, 10)
m.value(:milton)
m.value(:ivania)
    #+END_SRC

*** ArrayList & Resizable Arrays
    - Create an array with a fixed amount of elements
    - Insert data
    - When full expand it to the double

*** String Builder
    - sentence =  sentence + w -->  will create a new  string instance
      each time
    - StringBuilder uses an arraylist and concatenate all the elements
      at the end building a string

** Breadth Tree Traversal
  #+BEGIN_SRC ruby
  class Node < Struct.new(:data, :left, :right)
    def breadth(acc = "")
      queue = Queue.new
      queue << self
      while !queue.empty? do
        current = queue.pop
	acc += "#{current.data}-"
	queue << current.left if current.left
	queue << current.right if current.right
      end
      puts acc
    end
  end

  #         :a
  #    :b        :c
  # :d    :e  :f
  r = Node.new(:a, Node.new(:b, Node.new(:d), Node.new(:e)), Node.new(:c, Node.new(:f)))
  > r.breadth
  a-b-c-d-e-f-
  #+END_SRC

* Learnings
  - Use paper and pencil or whiteboard
  - Make sure to have an example of expected input and output
  - Make sure you have different examples
  - Think about arguments and return type
  - Come up with a quick solution
  - Think about edge cases
  - Worry about runtime complexity
  - Worry about space complexity
  - Define everything in just one function if you are using Ruby + LinkedLists
  - Remember that you can modify a data structure
  - Do you need to collect the data or just print it?
  - You can delete elements of the set of the solution when they are not useful anymore
    - Stack: (7)
  - Swapping name of data structures when necessary
    - Stack: (12)
  - Visualize in a better way the solutions; ask you if you already have the answer
  - Use the API of the data structure when extra space is not allowed
  - Check what happen with the Data Structure after performing an operation. Work with real life examples.
  - When calculating the middle keep in mind even and odd results
  - Circular indexes can go negative or around an array

* Resources
Big O notation: 36:02
https://www.youtube.com/watch?v=YWnBbNj_G-U
