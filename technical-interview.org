* Array and Strings [8/9]
  - [X] *Is Unique*: Implement an algorithm to determine if a string has
    all unique  characters.  What  if you  cannot use  additional data
    structures?
    1. This  solution is ~O(len(string) +  len(letters.values))~, thus
       ~O(n)~.   I  am  making  the assumption  that  hash  access  is
       constant.
      #+BEGIN_SRC ruby
  def is_unique?(string)
    letters = Hash.new(0)
    string.each_char do |char|
      letters[char] += 1
    end
    letters.values.select{|counter| counter > 1}.empty?
  end
     #+END_SRC
    2. This solution is ~O(n * log(n) + n)~, thus ~O(n * log n)~.  I am
       assuming that I cannot use an additional data structure.
       #+BEGIN_SRC ruby
  def is_unique?(string)
    sorted_string = string.split(//).sort
    next_index = 1
    result = true
    sorted_string[0..-2].each do |char|
      if char == sorted_string[next_index]
	result = false
	break
      end
      next_index += 1
    end
    result
  end
       #+END_SRC

  - [X] *Check permutation* Given two strings write a method to decide
    if one is a permutation of the other.
    #+BEGIN_SRC ruby
    def permutation(s1, s2)
      new_s1 = s1.split(//)
      new_s2 = s2.split(//)
      store = {}
      new_s2.each do |char|
        store[char] = true
      end

      result = true
      new_s1.each do |char|
        if !store.has_key?(char)
          result = false
	  break
	end
      end
      result
    end
    #+END_SRC

  - [X] *URLify*
    The solution is ~O(n + n)~, this ~O(n)~.

    #+BEGIN_SRC ruby
def urilify(string_array, size)
  spaces_index = []
  string_array[0..(size - 1)].each_with_index do |char, index|
    spaces_index << index if char == " "
  end

  current_index = spaces_index.count * 2 + size - 1
  string_index = size - 1

  while(current_index >= 0) do
    if spaces_index.include?(string_index)
      string_array[current_index] = "0"
      string_array[current_index - 1] = "2"
      string_array[current_index - 2] = "%"
      current_index -= 3
    else
      string_array[current_index] = string_array[string_index]
      current_index -= 1
    end
    string_index -= 1
  end
  string_array
end
    #+END_SRC

  - [X] *Palindrome  Permutation*  Given  a  string,  check  if  any
    permutation of  it is a palindrome.   The solution I came  up is a
    recursive  solution,  and I'm  pretty  sure  that is  exponential.
    However I don't know how to prove that.
    #+BEGIN_SRC ruby
def remaining_array(init, array)
  size = array.count
  size.times.map do |index|
    i = (init + index) % size
    array[i]
  end[1..-1]
end


def permutation(array)
  return array if array.empty?
  return [array] if array.count == 1
  results = []
  array.each_with_index do |e, index|
    permutation(remaining_array(index, array)).each do |a|
      results << [e].concat(a)
    end
  end
  results
end

def palindrome?(array)
  left_index = 0
  right_index = -1
  flag = true
  limit = (array.size/2.to_f).ceil
  array.size.times do |index|
    if right_index.abs > limit
      break
    end

    if array[index] != array[right_index] && (!array[index].blank? && !array[right_index].blank?)
      flag = false
      break
    end
    right_index -= 1
  end
  flag
end

def is_palindrome(s1)
  array = s1.split(//)
  permutation(array).select{|a| palindrome?(a) == true}.any?
end
    #+END_SRC

  - [X] *One Away*
    Given two strings, write a function to check if they are one edit (or zero edits) away.
    #+BEGIN_SRC ruby
def is_one_away?(s1, s2)
  longest, shortest = s1.size > s2.size ? [s1, s2] : [s2, s1]
  counter = 0
  shortest_index = 0
  longest.split(//).each_with_index do |char, index|
    if char == shortest[shortest_index]
      shortest_index += 1
      next
    end

    if longest[index+1] == shortest[shortest_index]
      counter += 1
    elsif longest[index+1] == shortest[shortest_index+1]
      counter += 1
      shortest_index += 1
    end
  end
  counter <= 1 ? true : false
end

is_one_away?("pale", "ple") == true
is_one_away?("pales", "pale") == true
is_one_away?("pale", "bale") == true
is_one_away?("pale", "bake") == false
    #+END_SRC

  - [X] *String Compression*
    aabcccccaaa `->` a2b1c5a3
    #+BEGIN_SRC ruby
def compress(string)
  normalized_string = string.split(//)
  repetitions = 0
  previous = normalized_string[0]
  new_string = ""
  normalized_string.each do |char|
    if (char == previous)
      repetitions += 1
    else
      new_string += "#{previous}#{repetitions}"
      previous = char
      repetitions = 1
    end
  end
  if normalized_string[-1] == previous
    new_string += "#{previous}#{repetitions}"
  end
  new_string
end
    #+END_SRC

  - [ ] *Rotate Matrix*

  - [X] *Zero Matrix* Given a MxN matrix, write an algorithm such that
    if an element is 0, its entire row and columns are set to 0.
    #+BEGIN_SRC ruby
def zero_matrix(matrix, row_count, column_count)
  rows = []
  columns = []
  matrix.each_with_index do |row, row_index|
    row.each_with_index do |element, column_index|
      if element == 0
        rows << row_index
        columns << column_index
      end
    end
  end
  rows.uniq.each do |row_index|
    matrix[row_index] = column_count.times.map{|c| 0}
  end
  columns.uniq.each do |column_index|
    matrix.each do |row|
      row[column_index] = 0
    end
  end
  matrix
end

zero_matrix([[1, 2], [3, 4], [5, 0]], 3, 2) == [[1, 0], [3, 0], [0, 0]]
    #+END_SRC

  - [X] *String Rotation*
    "waterbottle" is a rotation of "erbottlewat"
    #+BEGIN_SRC ruby
def is_rotation(s1, s2)
  "#{s2}#{s2}".include?(s1)
end

is_rotation("waterbottle", "erbottlewat") == true
    #+END_SRC
